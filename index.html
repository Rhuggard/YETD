<html>
<head>
	<script
  src="https://code.jquery.com/jquery-3.4.1.min.js"
  integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
  crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/rot-js@2/dist/rot.js"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<style>
	@font-face {
	    font-family: norwester;
	    src: url("norwester.otf") format("opentype");
	}

	@font-face {
	    font-family: yetd;
	    src: url("YETD_Font.ttf") format("truetype");
	}

	body{
		background-color: black;
		width:100%;
		height: 100%;
		margin: 0px;
		font-family: norwester;
    	color:white;
    	font-size: 20px;
    	overflow: hidden;
	}

/**/
	#begin{
		border-bottom: 4px solid #CC3333;
		width:100%;
	}

	#begin span{
		background: black;
	    position: relative;
	    top: 13px;
	    padding: 15px;
	}

/**/
	.rhsTapLine{
		border-bottom: 4px solid #CC3333;
		width:100%;
		position: relative;
		transition: right ease-in-out 0.1s; /*For non fullscreen slide out animations*/
		right:0px;
	}

	.rhsTapLine .rhsText{
    background: black;
    position: absolute;
    top: -35px;
    padding: 15px;
    right: 15px;
    font-size: 33px;
	}

	.rhsTapLine .lhsText{
	background: black;
    position: absolute;
    top: -34px;
    padding: 11px;
    left: 12px;
    font-size: 16px;
	}

	#wrapper{
	    text-align: center;
	    width: 100%;
	    height: 100%;
	}

	#title{
	    color: white;
	    display: inline-block;
	    height: 55%;
	}

	.simpleImage{
		width: 100%;
		top: 33%;
		position: relative;
	}

	.graveYard{
		position: absolute;
		bottom: 3px;
		left: 50%;
		width: 80px;
		transform: translateX(-40px);
	}


/* each screen has this class */
	.screen{
		width:100%;
		height: 100%;
		position: absolute;
		right:0%;
		top:0%;
		transition: right ease-in-out 0.1s;
	}

	.exit {
	  right: 100%;
	}

	.offScreen{
		right:-100%;
	}

	.textScreenHeading{
	    padding-top: 30px;
	    padding: 15px;
	    font-size: 22px;
	    text-align: left;
   	}

	.textScreenBody{
    text-align: left;
    padding: 15px 25px 15px 15px;
    font-size: 19px;
	}

	.textDisplay{
		height: 40%;
    position: relative;
    overflow: hidden;
    margin-bottom: 30px;
	}

	.textWrapper{
		position: absolute;
		bottom: 0px;
	}

	.mapCell.wall {
    color: black;
    border: 4px solid transparent;
  }



/* GAME STUFF*/

	#gameScreen{
		background-color: black;
	}

	.mapCell{
		text-align: center;
    line-height: 80px;
    font-size: 60px;
    font-family: 'yetd';
    /* position: absolute; */
    border: 4px solid white;
    opacity: 0.6;
    width: 80px;
    height: 80px;
    min-width: 80px;
    min-height: 80px;
    display: inline-block;
    margin: 4px;

	}

	#mapWrapper{
    height: 60%;
    width: 100%;
    position: absolute;
    top: 0px;
    left: 0px;
    text-align: initial;
	}

	#map{
		width: 10000px;
    height: 10000px;
    overflow: hidden;
    left: 0px;
    position: relative;
    top: 0px;
    transition: 0.1s ease-in-out;

  }

  .row{
  	display: flex;
  }

  .canMoveCell{
  	border-color:white;
  	opacity: 1.0;
  }

  .fail{
  	color:red;
  }


</style>


</head>

<body>

<div id='wrapper'>


<!-- First Screen -->
<div id='TitleScreen' class='screen'>
	<div id='title'>
		<img class='simpleImage' src='Title.png'>
	</div>
	<div id='begin'>
		<span>TAP TO BEGIN</span>
	</div>
	<img class='graveYard' src='Graveyard.png'>
</div>

<!-- Second Screen -->
<div id='OpeningScreen' class='screen textScreen offScreen'>
	<div class='textDisplay'>
		<div class='textWrapper'>
			<div class='TextScreenHeading'>
				You enter the dungeon...
			</div>
			<div id='openingText' class='TextScreenBody'>
				The foul stench of dead adventurers seeps from the depths. The legend that lured them in is what has brought you here and as the light from the outside fades, so too does your hope to ever return. Unless the legend is true...
			</div>
			<div id='secondText' class='TextScreenBody'>
				The floor is wet with what you assume is dirty water. The damp air makes it slightly hard to breathe, but you know that this is the least of your concerns.
			</div>
		</div>
	</div>
	<div class='rhsTapLine'>
		<span class='rhsText'>Next</span>
	</div>
</div>

<!-- Third Screen -->
<div id='GameScreen' class='screen offScreen'>
	<div id='mapWrapper'>
		<div id='map'>
			<!-- Map Tiles go here -->

		</div>
		<div class='rhsTapLine' id='tapAdjacentHint'>
			<span class='lhsText'>Tap On Adjacent </br> tiles to move</span>
			<span class='rhsText'>Got It!</span>
		</div>
	</div>
</div>

</div>

</body>


<script>


$(document).ready(function(){
	//Prep
	$("#secondText").hide();

	//First Screen
	$( "#begin" ).mouseup(function() {
	  $("#TitleScreen").addClass( "exit");
	  $("#OpeningScreen").removeClass( "offScreen");
	  rpgText($("#OpeningScreen .textWrapper"),$("#OpeningScreen .TextScreenHeading"), $("#OpeningScreen #openingText"));
	  // rpgText($("#OpeningScreen .textWrapper"),$("#OpeningScreen .TextScreenHeading"), $("#OpeningScreen #openingText"));
	});


	// Second Screen Next button
	$( "#OpeningScreen .rhsTapLine" ).click(function() {
		$("#secondText").show();
		rpgText($("#OpeningScreen .textWrapper"), null, $("#OpeningScreen #secondText"));
		$(this).unbind('click');
		$( "#OpeningScreen .rhsTapLine span").text("Close");
		$(this).click(third);
	});

	function third(){

		$("#OpeningScreen").addClass( "exit");
		$("#GameScreen").removeClass( "offScreen");
		new game();

		// get rid of hint
		$('#tapAdjacentHint').click(function() {
				$(this).addClass('exit');
			});
		}

		//Third Screen

});


var map;
var player = {};

// Game Code
class game{
	constructor(){
			gameSetup(game);
			play(map);		
	}

}

// MAP VIEW
function updateMapView(){
	playerPosition = game.player.pos;
	for (i = 0; i < game.mapView.x; i++){
		for (j = 0; j < game.mapView.y; j++){
			here = new Vec2(i,j);
			current = here.getCell();
			current.attr('class', 'mapCell');
			// Cell logic
			if(playerPosition.x == i && playerPosition.y == j){
				current.text("@");
			}else{
				t = map.getTile(here).symbol;
				if(t == 'Y'){ current.addClass('wall') };
				current.text(t);
			}

			d = playerPosition.distanceTo(here);
			if(d <= 1) {
				current.addClass('canMoveCell');
			}
		}
	}
	cameraTo(playerPosition);
}

//UTILITY
class Dice {
	constructor(sides){
		this.sides = sides;
	}
  roll() {
    var randomNumber = Math.floor(Math.random() * this.sides) + 1;
    return randomNumber;
  }

}

// Map
class GameMap extends Array{

	constructor(x,y){
		super();
		this.x = x;
		this.y = y;
		// this.startingMap(x,y,this.getRandomTile);
		this.startingMap(x,y,function(){return new Tile(' ')});
		// this.arenaMap(x,y,this);
		this.dungeonMap(x,y,this);
		// this.startingMap(x,y,);
		this.downstairs = false;
		var freeTiles = this.listFreeTiles();
		for (var i = freeTiles.length - 1; i >= 0; i--) {
			var v = freeTiles[i];
			v.getCell().css('background-color','red');
		}
		player.pos = freeTiles[new Dice(freeTiles.length).roll()];

	}


	listFreeTiles(){
		return this.listTilesCondition(function(tile){
			if(tile.symbol == ' '){
				return true;
			}
			return false;
		});
	}

	// WIP
	listTilesCondition(conditionFunction){
		var list = new Array();
		for (var ix = 0; ix < this.x; ix++) {
			for (var jy = 0; jy < this.y; jy++) {
				if(conditionFunction(this[ix][jy])){
					list.push(new Vec2(ix,jy));
				}
			}
		}
		return list;
	}

	userCallback(scope){
		return function(x, y, value) {
			// SHOW(ROT.Util.format("Value %s generated at [%s,%s]", value, x, y));
			console.log(" X: " + x + " Y: " + y + "Value: " + value);
			if(value){
				scope[x][y] = new Wall('Y');
			} else {
				scope[x][y] = scope.getRandomTile(scope);
			}
		}
	}

	arenaMap(x,y,scope){
		var ROTMap = new ROT.Map.Arena(x, y);
		ROTMap.create(scope.userCallback(scope));
	}

	dungeonMap(x,y,scope){
		ROT.RNG.setSeed(1234);
		var DMap = new ROT.Map.Digger(x,y);

		var addDoor = function(x, y) {
		    scope[x][y] = new Door('D');
		}

		var rooms = DMap.getRooms();
		for (var i=0; i<rooms.length; i++) {
		    var room = rooms[i];
		    SHOW(ROT.Util.format("Room #%s: [%s, %s] => [%s, %s]",
		        (i+1),
		        room.getLeft(), room.getTop(),
		        room.getRight(), room.getBottom()
		    ));

		    room.getDoors(addDoor);
		}
		DMap.create(scope.userCallback(scope));
	}

	startingMap(x,y, createTileFunc){
		// Build Map
		for (var i = 0; i < x; i++) {
			this[i] = new Array();
			for (var j = 0; j < y; j++) {
				this[i][j] = createTileFunc(this);
			}
		}
	}

	getRandomTile(scope){
		var t;
		var n = new Dice(20).roll();
		switch(n){
			case 1: t = new Chest('c');break;
			case 2: t = new Monster('e');break;
			case 3: if(!scope.downstairs){
				t = new Stairs('>');
				scope.downstairs = true;
			} else {
				t = new Tile(' ');
			}; break;
			case 4: t = new Wall(' ');
			default: t = new Tile(' ');
		}
		return t;
	}

	getTile(v){
		if(this.inBounds(v)){
			return this[v.x][v.y];
		} else {
			return new Wall('x');
		}
	}

	inBounds(v){
		if(v.x < 0 || v.y < 0 || v.x >= this.x || v.y >= this.y){
			return false;
		}else {
			return true;
		}
	}

}

class Tile{
	constructor(symbol){
		this.type = 'tile';
		this.symbol = symbol;
		this.passable = true;
		this.encounter = false;
		this.class = '';
	}
}

class Monster extends Tile{
	constructor(symbol){
		super(symbol);
		this.type = 'Monster';
		this.passable = false;
		this.encounter = true;
	}

	runEncounter(){

	}
}

class Door extends Tile{
	constructor(symbol){
		super(symbol);
		this.type = 'door';
		this.passable = false;
		this.encounter = true;
	}

	runEncounter(){
		console.log('you walk into a door');
	}
}

class Stairs extends Tile{
	constructor(symbol){
		super(symbol);
		this.type = 'stairs';
		this.passable = true;
		this.encounter = true;
	}

	runEncounter(){
		alert('You WIN!');
	}
}

class Chest extends Tile{
	constructor(symbol){
		super(symbol);
		this.type = 'chest';
		this.passable = false;
	}	
}

class Wall extends Tile{
	constructor(symbol){
		super(symbol);
		this.passable = false;
		this.class = 'wall';
	}
}

// Vector Helpers
class Vec2 {

	constructor(x,y){
		this.x = x;
		this.y = y;
	}

	distanceTo(v){
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		return Math.pow(dx,2) + Math.pow(dy,2);
	}

	getCell(){
		return $('#cell_' + this.x + '_' + this.y);
	}
}

// center view on square x,y
function cameraTo(v){
	x = v.x;
	y = v.y;
	spacing = {};
	spacing.initialOffset = {};
	spacing.x = -96;
	spacing.y = spacing.x;
	spacing.initialOffset.x = ($(window).width() + spacing.x)/2;
	spacing.initialOffset.y = ($(window).height() + spacing.y)/2;

	$('#map').css({'left': x*spacing.x + spacing.initialOffset.x + 'px',
		'top': y*spacing.y + spacing.initialOffset.y + 'px'});
}

function gameSetup(game){

	map = new GameMap(50,50);
	buildMapView(50, 50);

	game.player = player;
	
	player.pos = new Vec2(new Dice(map.x - 1).roll(), new Dice(map.y - 1).roll());

	game.redraw = function(){
		updateMapView();
		// TODO: update UI/draw UI
	}


	// First draw!
	game.redraw();

	player.move = function(v){
		movingTo = new Vec2(player.pos.x + v.x,player.pos.y + v.y);
		t = map.getTile(movingTo);
		if(t.passable){
			player.pos = movingTo
			// Incremenet move counter?
		} 
		if(t.encounter) {
			t.runEncounter();
		}
		game.redraw();
	}

	player.left = function(){
		player.move(new Vec2(-1,0));
	}

	player.up = function(){
		player.move(new Vec2(0,-1));
	}

	player.right = function(){
		player.move(new Vec2(1,0));
	}

	player.down = function(){
		player.move(new Vec2(0,1));
	}

	// Bind Keys
	$(document).keydown(function(e) {
	    switch(e.which) {
	        case 37: // left
	        player.left();
	        break;

	        case 38: // up
	        player.up();
	        break;

	        case 39: // right
	        player.right();
	        break;

	        case 40: // down
	        player.down();
	        break;

	        default: return; // exit this handler for other keys
	    }
	    e.preventDefault(); // prevent the default action (scroll / move caret)
	});
}

function buildMapView(x, y){
game.mapView = {};
game.mapView.x = x;
game.mapView.y = y;

	for (var iy = 0; iy < y; iy++){
		var myRow = $('<div></div>');
		myRow.attr('id', 'row_' + iy);
		myRow.addClass('row');
		$("#map").append(myRow);
		for (jx = 0; jx < x; jx++){
			var myCell = $('<div></div>');
			myCell.attr('id', 'cell_' + jx + '_' + iy);
			myCell.addClass('mapCell');
			$("#row_" + iy).append(myCell);
		}
	}
}

function play(map){
// TODO:
}

function showMap(map){
	mapStr = "";
	for(i = 0; i < map.length; i++ ){
		for(j = 0; j < map[i].length; j++){
			mapStr += map[i][j];
		}
		mapStr += '\n';
	}
	return mapStr;
}

// UTILTITIES

// Typing delays in milliseconds.
var textDelay = 5; //delay between each letter
var speedBetweenLines = 400; //delay between heading and main text

// Fix size so typing doesn't resize element
function fixDimensions(e){
  e.width(e.width());
  e.height(e.height());
}

// UnFix dimensions so window resizing works again.
function unFixDimensions(e){
  e.width("");
  e.height("");
}

function rpgText(element, heading, body){
  //Fix Height
  fixDimensions(element);

  if(heading != null){
  	headingText = heading.text();
  	heading.text("");
  }

  bodyText = body.text();
  body.text("");

  if(heading != null){
	  typeWriter(headingText, heading, function(){
	  	setTimeout(typeBody(element), speedBetweenLines);
		});
	} else {
		typeBody(element);
	}

  function typeBody(element){
    typeWriter(bodyText, body, function(){
			unFixDimensions(element);
    });
  };

}

function typeWriter(str, target, callback){
  quickType(str, target, 0, callback);
}

function quickType(str, target, i, callback) {
    // If full string hasn't yet been typed out, continue typing
    if (i < str.length) {
        target.text(target.text() + str.charAt(i));
        i++;
        setTimeout(function(){ quickType(str, target, i, callback); }, textDelay);
    } else {
      // Done so callback time
      if(callback)
        callback();
    }
}

</script>


</html>